<!doctype html>
<html lang="ja">
  <head>
      <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
          <title>Arc Breakout (Circle Blocks)</title>
            <style>
    html, body { margin:0; height:100%; background:#0b1020; overflow:hidden; touch-action:none; }
        canvas { display:block; width:100vw; height:100vh; }
          </style>
  </head>
  <body>
    <canvas id="c"></canvas>
    <script>
      (() => {
          const canvas = document.getElementById('c');
          const ctx = canvas.getContext('2d', { alpha: false });

          function resize() {
                const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
                canvas.width = Math.floor(innerWidth * dpr);
                canvas.height = Math.floor(innerHeight * dpr);
                ctx.setTransform(dpr,0,0,dpr,0,0);
              }
          addEventListener('resize', resize, { passive: true });
          resize();

          // ---------- Utils ----------
          const TAU = Math.PI * 2;
          const clamp = (x,a,b) => Math.max(a, Math.min(b,x));
          const len = (x,y) => Math.hypot(x,y);
          const norm = (x,y) => {
                const l = Math.hypot(x,y) || 1;
                return [x/l, y/l];
              };
          const dot = (ax,ay,bx,by) => ax*bx + ay*by;
          const reflect = (vx,vy,nx,ny) => {
                // v' = v - 2(vÂ·n)n
                const d = vx*nx + vy*ny;
                return [vx - 2*d*nx, vy - 2*d*ny];
              };
          const angleOf = (x,y) => Math.atan2(y,x);
          const wrapAngle = (a) => {
                // [-pi, pi)
                while (a >= Math.PI) a -= TAU;
                while (a < -Math.PI) a += TAU;
                return a;
              };
          const angleInArc = (a, a0, a1) => {
                // handle wrap: treat arc span as shortest direction from a0 to a1 by normalization
                a = wrapAngle(a);
                a0 = wrapAngle(a0);
                a1 = wrapAngle(a1);

                const span = wrapAngle(a1 - a0);
                const rel  = wrapAngle(a - a0);

                if (span >= 0) return rel >= 0 && rel <= span;
                // negative span means arc goes "backwards"
                return rel <= 0 && rel >= span;
              };

          // ---------- Game Params ----------
          const state = {
                score: 0,
                lives: 3,
                running: true,
                message: 'TAP to launch',
              };

          const world = {
                w: () => innerWidth,
                h: () => innerHeight,
                topMargin: 64,
                wall: 10,
              };

          // Paddle: arc on a circle centered near bottom
          const paddle = {
                cx: () => innerWidth/2,
                cy: () => innerHeight*0.92,
                radius: () => Math.min(innerWidth, innerHeight) * 0.28,
                thickness: 18,
                span: Math.PI * 0.9,      // arc length (radians)
                angle: -Math.PI/2,        // arc centered upward by default
                maxTurnPerPx: 0.006,      // sensitivity
              };

          // Ball
          const ball = {
                x: innerWidth/2,
                y: innerHeight*0.72,
                r: 8,
                speed: 420,    // px/s (kept constant)
                vx: 0,
                vy: 0,
                launched: false,
              };

          function resetBall() {
                ball.x = innerWidth/2;
                ball.y = innerHeight*0.72;
                ball.vx = 0;
                ball.vy = 0;
                ball.launched = false;
                state.message = 'TAP to launch';
              }

          // Bricks: circles in rows
          let bricks = [];
          function makeBricks() {
                bricks = [];
                const cols = Math.max(6, Math.floor(innerWidth / 60));
                const rows = 5;
                const gap = 10;
                const r = clamp(innerWidth / (cols*2.6), 12, 20);

                const totalW = cols*(2*r) + (cols-1)*gap;
                const startX = (innerWidth - totalW)/2 + r;
                const startY = world.topMargin + 40;

                for (let y=0; y<rows; y++) {
                        for (let x=0; x<cols; x++) {
                                  bricks.push({
                                              x: startX + x*(2*r + gap),
                                              y: startY + y*(2*r + gap),
                                              r,
                                              hp: 1,
                                            });
                                }
                      }
              }
          makeBricks();

          // ---------- Input (touch drag to rotate paddle) ----------
          let dragging = false;
          let lastX = 0;

          const getClientX = (e) => (e.touches ? e.touches[0].clientX : e.clientX);
          const getClientY = (e) => (e.touches ? e.touches[0].clientY : e.clientY);

          function onDown(e) {
                e.preventDefault();
                const x = getClientX(e);
                const y = getClientY(e);

                // Tap to launch if not launched
                if (!ball.launched && state.running) {
                        // launch upward with slight angle depending on tap x
                        const dx = (x - innerWidth/2) / (innerWidth/2);
                        const ang = -Math.PI/2 + dx * (Math.PI*0.25);
                        ball.vx = Math.cos(ang) * ball.speed;
                        ball.vy = Math.sin(ang) * ball.speed;
                        ball.launched = true;
                        state.message = '';
                      }

                dragging = (y > innerHeight*0.6); // only bottom area rotates
                lastX = x;
              }
          function onMove(e) {
                if (!dragging) return;
                e.preventDefault();
                const x = getClientX(e);
                const dx = x - lastX;
                lastX = x;

                paddle.angle += dx * paddle.maxTurnPerPx;
                // clamp a bit so it doesn't go too extreme; keep centered upward-ish
                paddle.angle = clamp(paddle.angle, -Math.PI*1.25, -Math.PI*0.25);
              }
          function onUp(e) {
                dragging = false;
              }

          canvas.addEventListener('touchstart', onDown, { passive:false });
          canvas.addEventListener('touchmove', onMove, { passive:false });
          canvas.addEventListener('touchend', onUp, { passive:false });
          canvas.addEventListener('mousedown', onDown, { passive:false });
          canvas.addEventListener('mousemove', onMove, { passive:false });
          canvas.addEventListener('mouseup', onUp, { passive:false });

          // ---------- Collision ----------
          function keepSpeedConstant() {
                const l = Math.hypot(ball.vx, ball.vy) || 1;
                ball.vx = (ball.vx / l) * ball.speed;
                ball.vy = (ball.vy / l) * ball.speed;
              }

          function collideWalls() {
                const left = world.wall;
                const right = innerWidth - world.wall;
                const top = world.wall;

                if (ball.x - ball.r < left) {
                        ball.x = left + ball.r;
                        ball.vx *= -1;
                      } else if (ball.x + ball.r > right) {
                              ball.x = right - ball.r;
                              ball.vx *= -1;
                            }
                if (ball.y - ball.r < top) {
                        ball.y = top + ball.r;
                        ball.vy *= -1;
                      }

                // bottom out
                if (ball.y - ball.r > innerHeight + 40) {
                        state.lives -= 1;
                        if (state.lives <= 0) {
                                  state.running = false;
                                  state.message = 'GAME OVER (tap to restart)';
                                } else {
                                          resetBall();
                                        }
                      }
              }

          function collideBrick(br) {
                const dx = ball.x - br.x;
                const dy = ball.y - br.y;
                const dist = Math.hypot(dx,dy);
                const minDist = ball.r + br.r;

                if (dist <= minDist) {
                        // push out
                        const [nx, ny] = norm(dx,dy);
                        const overlap = (minDist - dist) + 0.5;
                        ball.x += nx * overlap;
                        ball.y += ny * overlap;

                        // reflect
                        [ball.vx, ball.vy] = reflect(ball.vx, ball.vy, nx, ny);
                        keepSpeedConstant();

                        br.hp -= 1;
                        if (br.hp <= 0) {
                                  state.score += 10;
                                  return true; // removed
                                }
                      }
                return false;
              }

          function collidePaddleArc() {
                const OX = paddle.cx();
                const OY = paddle.cy();
                const Rp = paddle.radius();
                const t = paddle.thickness;
                const aCenter = paddle.angle;
                const a0 = aCenter - paddle.span/2;
                const a1 = aCenter + paddle.span/2;

                const dx = ball.x - OX;
                const dy = ball.y - OY;
                const d = Math.hypot(dx, dy);

                // radial ring check
                const radialDiff = Math.abs(d - Rp);
                if (radialDiff > ball.r + t/2) return;

                // angle range check
                const ang = angleOf(dx, dy);
                if (!angleInArc(ang, a0, a1)) return;

                // avoid reflecting if moving away from the arc normal
                const [nx, ny] = norm(dx, dy); // radial normal
                const approaching = dot(ball.vx, ball.vy, nx, ny) < 0;
                if (!approaching) return;

                // push to boundary
                const targetD = (d < Rp) ? (Rp - (t/2 + ball.r + 0.5)) : (Rp + (t/2 + ball.r + 0.5));
                const push = targetD - d;
                ball.x += nx * push;
                ball.y += ny * push;

                // reflect
                [ball.vx, ball.vy] = reflect(ball.vx, ball.vy, nx, ny);

                // add a tiny "control" based on where it hits along the arc:
                // tangential tweak without changing speed overall
                const tx = -ny, ty = nx; // tangent unit
                const rel = wrapAngle(ang - aCenter); // within [-span/2, span/2] usually
                const spin = clamp(rel / (paddle.span/2), -1, 1) * 80; // px/s tweak
                ball.vx += tx * spin;
                ball.vy += ty * spin;

                keepSpeedConstant();
              }

          // ---------- Game Loop ----------
          let last = performance.now();

          function update(dt) {
                if (!state.running) return;

                if (ball.launched) {
                        ball.x += ball.vx * dt;
                        ball.y += ball.vy * dt;

                        collideWalls();
                        collidePaddleArc();

                        // bricks
                        for (let i = bricks.length - 1; i >= 0; i--) {
                                  const removed = collideBrick(bricks[i]);
                                  if (removed) bricks.splice(i, 1);
                                }

                        // win
                        if (bricks.length === 0) {
                                  state.running = false;
                                  state.message = 'CLEAR! (tap to restart)';
                                }
                      } else {
                              // keep ball near center-ish before launch
                              ball.x = innerWidth/2;
                              ball.y = innerHeight*0.72;
                            }
              }

          function draw() {
                // background
                ctx.fillStyle = '#0b1020';
                ctx.fillRect(0,0,innerWidth,innerHeight);

                // walls frame
                ctx.strokeStyle = 'rgba(255,255,255,0.15)';
                ctx.lineWidth = world.wall;
                ctx.strokeRect(world.wall/2, world.wall/2, innerWidth-world.wall, innerHeight-world.wall);

                // bricks
                for (const br of bricks) {
                        ctx.beginPath();
                        ctx.arc(br.x, br.y, br.r, 0, TAU);
                        ctx.fillStyle = 'rgba(120,200,255,0.9)';
                        ctx.fill();
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = 'rgba(255,255,255,0.35)';
                        ctx.stroke();
                      }

                // paddle arc
                const OX = paddle.cx();
                const OY = paddle.cy();
                const Rp = paddle.radius();
                const aCenter = paddle.angle;
                const a0 = aCenter - paddle.span/2;
                const a1 = aCenter + paddle.span/2;

                ctx.beginPath();
                ctx.arc(OX, OY, Rp, a0, a1);
                ctx.strokeStyle = 'rgba(255,220,120,0.95)';
                ctx.lineWidth = paddle.thickness;
                ctx.lineCap = 'round';
                ctx.stroke();

                // ball
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.r, 0, TAU);
                ctx.fillStyle = 'rgba(255,255,255,0.95)';
                ctx.fill();

                // HUD
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.font = '16px system-ui, -apple-system, Segoe UI, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`Score: ${state.score}`, 16, 28);
                ctx.fillText(`Lives: ${state.lives}`, 16, 50);

                if (state.message) {
                        ctx.textAlign = 'center';
                        ctx.font = '18px system-ui, -apple-system, Segoe UI, sans-serif';
                        ctx.fillText(state.message, innerWidth/2, innerHeight*0.55);
                        ctx.textAlign = 'left';
                      }
              }

          function loop(now) {
                const dt = Math.min(0.02, (now - last) / 1000);
                last = now;

                update(dt);
                draw();
                requestAnimationFrame(loop);
              }
          requestAnimationFrame(loop);

          // tap to restart when finished
          canvas.addEventListener('click', () => {
                if (state.running) return;
                state.score = 0;
                state.lives = 3;
                state.running = true;
                makeBricks();
                resetBall();
              });

      })();
    </script>
  </body>
</html>

